import EventEmitter from './EventEmitter';
import bindMethodContext from './utils/bindMethodContext';
import getClassExtender from './utils/classExtender';

const EMITTER_KEY = '__WRAMP_EMITTER_KEY__';

const extendClass = getClassExtender()

/**
 * Event types published from a wrapped class
 * generated by `defineProxyClass`.
 */
export const EventTypes = {
  METHOD_CALL_START: 'METHOD_CALL_START',
  METHOD_CALL_END: 'METHOD_CALL_END',
};

/**
 * Register an event handler of a given wrapped object.
 * @return A function to unsubscribe.
 */
export const subscribe = (wrappedObject, eventType, handler) => {
  const emitter = wrappedObject[EMITTER_KEY];
  return emitter.on(eventType, handler);
};

/**
 * Wrap a given class and generate a new class
 * which allows us to subscribe its method calls.
 * @return A wrapped class.
 */
export default function defineProxyClass(OriginalClass, configs = {}) {
  const ProxyClass = defineSubClass(OriginalClass);
  const wrappedMethods = wrapMethods(
    OriginalClass.name,
    OriginalClass.prototype,
    configs.isTarget
  );
  Object.assign(ProxyClass.prototype, wrappedMethods);
  return ProxyClass;
}

const defineSubClass = (OriginalClass, config = {}) => {
  return extendClass(OriginalClass, _this => {
    Object.defineProperty(_this, EMITTER_KEY, {
      value: new EventEmitter(),
      configurable: false,
      enumerable: false,
      writable: false,
    });

    if (config.autoBind === true) {
      bindMethodContext(_this);
    }
  })
};

const wrapMethods = (className, proto, isTarget = () => true) => {
  const properties = Object.getOwnPropertyNames(proto);

  return properties.reduce((wrappedProto, name) => {
    const method = proto[name];
    if (typeof method === 'function') {
      const wrappedMethod = isTarget(name, method)
        ? wrapMethod(method, name, className)
        : method;
      wrappedProto[name] = wrappedMethod;
    }
    return wrappedProto;
  }, {});
};

const wrapMethod = (method, methodName, className) => {
  function wrappedMethod(...args) {
    /* eslint-disable no-invalid-this */

    const emitter = this[EMITTER_KEY];
    const methodData = {
      className,
      methodName,
      method: this[methodName],
      originalMethod: method,
      args,
    };

    emitter.emit(EventTypes.METHOD_CALL_START, methodData);
    const returnValue = method.apply(this, args);
    emitter.emit(EventTypes.METHOD_CALL_END, methodData);
    return returnValue;

    /* eslint-enable no-invalid-this */
  }

  setMethodName(wrappedMethod, methodName);
  return wrappedMethod;
};

const setMethodName = (method, name) => {
  Object.defineProperty(method, 'name', {
    value: name,
    enumerable: false,
    writable: false,
    configurable: true,
  });
};
